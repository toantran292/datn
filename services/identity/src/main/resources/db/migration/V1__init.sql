-- V1__identity_init.sql
-- UTS Identity: schema init (users, orgs, memberships, rbac, invites, audit, outbox)

-----------------------------
-- Extensions
-----------------------------
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- gen_random_uuid()

-----------------------------
-- Tables
-----------------------------

-- USERS
CREATE TABLE IF NOT EXISTS users (
                                     id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email          CITEXT NOT NULL UNIQUE,
    password_hash  TEXT   NOT NULL,
    disabled       BOOLEAN NOT NULL DEFAULT FALSE,
    created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at     TIMESTAMPTZ NOT NULL DEFAULT now()
    );

-- ORGANIZATIONS
CREATE TABLE IF NOT EXISTS organizations (
                                             id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug           CITEXT NOT NULL UNIQUE,
    display_name   TEXT   NOT NULL,
    created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at     TIMESTAMPTZ NOT NULL DEFAULT now()
    );

-- MEMBERSHIPS (user ↔ org; cache roles + member_type)
-- member_type: 'STAFF' | 'PARTNER'
CREATE TABLE IF NOT EXISTS memberships (
                                           user_id        UUID NOT NULL,
                                           org_id         UUID NOT NULL,
                                           roles          TEXT[] NOT NULL DEFAULT '{}',
                                           member_type    TEXT   NOT NULL DEFAULT 'STAFF',
                                           created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (user_id, org_id),
    CONSTRAINT memberships_member_type_chk
    CHECK (member_type IN ('STAFF','PARTNER'))
);

-- ROLES (system / custom)
CREATE TABLE IF NOT EXISTS roles (
                                     id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                     name         CITEXT NOT NULL UNIQUE, -- OWNER, ADMIN, MEMBER, PROJECT_ADMIN, ...
                                     description  TEXT,
                                     builtin      BOOLEAN NOT NULL DEFAULT FALSE
);

-- PERMISSIONS (atomic permissions)
CREATE TABLE IF NOT EXISTS permissions (
                                           id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                           name         CITEXT NOT NULL UNIQUE, -- org.read, user.invite, project.manage, ...
                                           description  TEXT
);

-- ROLE_PERMISSIONS (many-to-many)
CREATE TABLE IF NOT EXISTS role_permissions (
                                                role_id  INT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    perm_id  INT NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, perm_id)
    );

-- ROLE_BINDINGS (assign role to user in a scope)
-- scope: 'ORG' | 'PROJECT'
CREATE TABLE IF NOT EXISTS role_bindings (
                                             id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id     UUID NOT NULL,        -- logical FK -> organizations.id
    user_id    UUID NOT NULL,        -- logical FK -> users.id
    role_id    INT  NOT NULL REFERENCES roles(id) ON DELETE RESTRICT,
    scope      TEXT NOT NULL DEFAULT 'ORG',
    scope_id   TEXT,                 -- nullable; when PROJECT, store PM.PROJECTS.id
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT role_bindings_scope_chk
    CHECK (scope IN ('ORG','PROJECT'))
    );

CREATE INDEX IF NOT EXISTS idx_role_bindings_org_user ON role_bindings (org_id, user_id);
CREATE INDEX IF NOT EXISTS idx_role_bindings_scope    ON role_bindings (scope, scope_id);

-- INVITATIONS (khi mời vào org)
-- LƯU Ý: domain Invitation có memberType, KHÔNG có roles
CREATE TABLE IF NOT EXISTS invitations (
                                           id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id      UUID   NOT NULL,     -- logical FK -> organizations
    email       CITEXT NOT NULL,
    token       TEXT   NOT NULL UNIQUE,
    member_type TEXT   NOT NULL DEFAULT 'STAFF',
    created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
    accepted_at TIMESTAMPTZ,
    CONSTRAINT invitations_member_type_chk
    CHECK (member_type IN ('STAFF','PARTNER'))
    );

CREATE UNIQUE INDEX IF NOT EXISTS ux_invitations_open_unique
    ON invitations (org_id, email)
    WHERE accepted_at IS NULL;

-- AUDIT_LOGS
CREATE TABLE IF NOT EXISTS audit_logs (
                                          id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                          actor_user_id  UUID,              -- logical FK -> users.id
                                          org_id         UUID,              -- logical FK -> organizations.id
                                          action         TEXT NOT NULL,     -- e.g. user.invited
                                          meta           JSONB,             -- extra context
                                          at             TIMESTAMPTZ NOT NULL DEFAULT now()
    );

CREATE INDEX IF NOT EXISTS idx_audit_logs_org_time ON audit_logs (org_id, at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor    ON audit_logs (actor_user_id, at DESC);

-- OUTBOX (Transactional Outbox)
CREATE TABLE IF NOT EXISTS outbox (
                                      id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                      topic        TEXT  NOT NULL,     -- identity.user.created, ...
                                      payload      JSONB NOT NULL,     -- <<-- JSONB để insert PGobject(json)
                                      created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
    published_at TIMESTAMPTZ
    );

-- For efficient polling of unpublished messages
CREATE INDEX IF NOT EXISTS idx_outbox_unpublished
    ON outbox (created_at)
    WHERE published_at IS NULL;

-----------------------------
-- Helpful triggers (updated_at)
-----------------------------
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_set_updated_at') THEN
CREATE TRIGGER trg_users_set_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_orgs_set_updated_at') THEN
CREATE TRIGGER trg_orgs_set_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
END IF;
END$$;

-----------------------------
-- Seed (minimal roles & perms)
-----------------------------
INSERT INTO roles (name, description, builtin) VALUES
                                                   ('OWNER',  'Organization owner (full access)', TRUE),
                                                   ('ADMIN',  'Organization admin', TRUE),
                                                   ('MEMBER', 'Organization member', TRUE),
                                                   ('PROJECT_ADMIN',  'Project-level admin', TRUE),
                                                   ('PROJECT_EDITOR', 'Project-level editor', TRUE),
                                                   ('PROJECT_VIEWER', 'Project-level viewer', TRUE)
    ON CONFLICT (name) DO NOTHING;

INSERT INTO permissions (name, description) VALUES
                                                ('org.read',               'Read organization info'),
                                                ('org.manage',             'Manage organization settings'),
                                                ('user.invite',            'Invite users to organization'),
                                                ('member.manage',          'Add/remove/update members'),
                                                ('rbac.manage',            'Manage role bindings'),
                                                ('project.manage',         'Create/update projects (PM)'),
                                                ('project.member.manage',  'Add/remove project members')
    ON CONFLICT (name) DO NOTHING;

WITH r AS (SELECT id, name FROM roles),
     p AS (SELECT id, name FROM permissions)
INSERT INTO role_permissions (role_id, perm_id)
SELECT r.id, p.id
FROM (
         VALUES
             ('OWNER','org.read'),
             ('OWNER','org.manage'),
             ('OWNER','user.invite'),
             ('OWNER','member.manage'),
             ('OWNER','rbac.manage'),
             ('OWNER','project.manage'),
             ('OWNER','project.member.manage'),

             ('ADMIN','org.read'),
             ('ADMIN','user.invite'),
             ('ADMIN','member.manage'),
             ('ADMIN','rbac.manage'),
             ('ADMIN','project.manage'),
             ('ADMIN','project.member.manage'),

             ('MEMBER','org.read'),

             ('PROJECT_ADMIN','project.manage'),
             ('PROJECT_ADMIN','project.member.manage'),
             ('PROJECT_ADMIN','org.read'),

             ('PROJECT_EDITOR','org.read'),
             ('PROJECT_VIEWER','org.read')
     ) m(role_name, perm_name)
         JOIN r ON r.name = m.role_name
         JOIN p ON p.name = m.perm_name
    ON CONFLICT DO NOTHING;

-----------------------------
-- Views (optional)
-----------------------------
CREATE OR REPLACE VIEW v_memberships AS
SELECT
    m.user_id,
    m.org_id,
    m.roles,
    m.member_type,
    m.created_at
FROM memberships m;

CREATE OR REPLACE VIEW v_role_bindings AS
SELECT
    rb.id,
    rb.org_id,
    rb.user_id,
    r.name AS role_name,
    rb.scope,
    rb.scope_id,
    rb.created_at
FROM role_bindings rb
         JOIN roles r ON r.id = rb.role_id;