-- Identity Service: Combined Migration
-- PostgreSQL 13+
-- This migration combines all previous migrations into a single file

-----------------------------
-- Extensions
-----------------------------
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- gen_random_uuid()

-----------------------------
-- Tables
-----------------------------

-- USERS
CREATE TABLE IF NOT EXISTS users (
  id                   UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email                CITEXT NOT NULL UNIQUE,
  password_hash        TEXT NOT NULL,
  disabled             BOOLEAN NOT NULL DEFAULT FALSE,
  display_name         TEXT,
  phone                VARCHAR(20),
  bio                  TEXT,
  avatar_asset_id      VARCHAR(64),
  email_verified_at    TIMESTAMPTZ,
  must_change_password BOOLEAN NOT NULL DEFAULT FALSE,
  created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at           TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_users_avatar_asset ON users (avatar_asset_id) WHERE avatar_asset_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_users_email_verified ON users (email_verified_at) WHERE email_verified_at IS NOT NULL;

COMMENT ON COLUMN users.display_name IS 'Human-readable display name for the user';

-- ORGANIZATIONS
CREATE TABLE IF NOT EXISTS organizations (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug           CITEXT NOT NULL UNIQUE,
  display_name   TEXT NOT NULL,
  description    TEXT,
  logo_asset_id  TEXT,
  llm_provider   VARCHAR(20),
  settings       JSONB DEFAULT '{}',
  status         VARCHAR(20) DEFAULT 'ACTIVE',
  lock_reason    TEXT,
  locked_at      TIMESTAMPTZ,
  locked_by      UUID REFERENCES users(id),
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_organizations_logo_asset_id ON organizations(logo_asset_id) WHERE logo_asset_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_organizations_status ON organizations(status);

COMMENT ON COLUMN organizations.settings IS 'JSON settings: {maxFileSizeMb, storageLimitGb, allowedFileTypes[], features: {aiReports, etc}}';

-- MEMBERSHIPS (user <-> org; cache roles + member_type)
-- member_type: 'STAFF' | 'PARTNER'
CREATE TABLE IF NOT EXISTS memberships (
  user_id        UUID NOT NULL,
  org_id         UUID NOT NULL,
  roles          TEXT[] NOT NULL DEFAULT '{}',
  member_type    TEXT NOT NULL DEFAULT 'STAFF',
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, org_id),
  CONSTRAINT memberships_member_type_chk CHECK (member_type IN ('STAFF','PARTNER'))
);

-- ROLES (system / custom)
CREATE TABLE IF NOT EXISTS roles (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         CITEXT NOT NULL UNIQUE,
  description  TEXT,
  builtin      BOOLEAN NOT NULL DEFAULT FALSE
);

-- PERMISSIONS (atomic permissions)
CREATE TABLE IF NOT EXISTS permissions (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         CITEXT NOT NULL UNIQUE,
  description  TEXT
);

-- ROLE_PERMISSIONS (many-to-many)
CREATE TABLE IF NOT EXISTS role_permissions (
  role_id  INT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  perm_id  INT NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (role_id, perm_id)
);

-- ROLE_BINDINGS (assign role to user in a scope)
-- scopes: 'SYSTEM' | 'ORG' | 'PROJECT'
CREATE TABLE IF NOT EXISTS role_bindings (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id     UUID,
  user_id    UUID NOT NULL,
  role_id    INT NOT NULL REFERENCES roles(id) ON DELETE RESTRICT,
  scope      TEXT NOT NULL DEFAULT 'ORG',
  scope_id   TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT role_bindings_scope_chk CHECK (scope IN ('SYSTEM','ORG','PROJECT')),
  CONSTRAINT role_bindings_scope_shape_chk CHECK (
    (scope = 'SYSTEM'  AND org_id IS NULL AND scope_id IS NULL) OR
    (scope = 'ORG'     AND org_id IS NOT NULL AND scope_id IS NULL) OR
    (scope = 'PROJECT' AND org_id IS NOT NULL AND scope_id IS NOT NULL)
  )
);

CREATE INDEX IF NOT EXISTS idx_role_bindings_org_user ON role_bindings (org_id, user_id);
CREATE INDEX IF NOT EXISTS idx_role_bindings_scope ON role_bindings (scope, scope_id);
CREATE INDEX IF NOT EXISTS idx_role_bindings_scope_only ON role_bindings (scope);

-- INVITATIONS (invite to org)
CREATE TABLE IF NOT EXISTS invitations (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id      UUID NOT NULL,
  email       CITEXT NOT NULL,
  token       TEXT NOT NULL UNIQUE,
  member_type TEXT NOT NULL DEFAULT 'STAFF',
  role        TEXT NOT NULL DEFAULT 'MEMBER',
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  accepted_at TIMESTAMPTZ,
  CONSTRAINT invitations_member_type_chk CHECK (member_type IN ('STAFF','PARTNER')),
  CONSTRAINT invitations_role_chk CHECK (role IN ('ADMIN', 'MEMBER'))
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_invitations_open_unique ON invitations (org_id, email) WHERE accepted_at IS NULL;

-- AUDIT_LOGS
CREATE TABLE IF NOT EXISTS audit_logs (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id         UUID NOT NULL REFERENCES organizations(id),
  user_id        UUID REFERENCES users(id),
  action         VARCHAR(50) NOT NULL,
  description    TEXT,
  metadata       JSONB DEFAULT '{}',
  ip_address     VARCHAR(45),
  user_agent     VARCHAR(500),
  created_at     TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_org_id ON audit_logs(org_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_logs_org_created ON audit_logs(org_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_org_action ON audit_logs(org_id, action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_metadata ON audit_logs USING GIN(metadata);

-- OUTBOX (Transactional Outbox)
CREATE TABLE IF NOT EXISTS outbox (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  topic        TEXT NOT NULL,
  payload      JSONB NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  published_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_outbox_unpublished ON outbox (created_at) WHERE published_at IS NULL;

-- EXTERNAL IDENTITIES
CREATE TABLE IF NOT EXISTS external_identities (
  provider   TEXT NOT NULL,
  subject    TEXT NOT NULL,
  user_id    UUID NOT NULL,
  email      CITEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (provider, subject)
);

CREATE INDEX IF NOT EXISTS idx_external_by_user ON external_identities(user_id);

-- REFRESH TOKENS
CREATE TABLE IF NOT EXISTS refresh_tokens (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id        UUID NOT NULL,
  token_hash     TEXT NOT NULL UNIQUE,
  org_id         UUID,
  expires_at     TIMESTAMPTZ NOT NULL,
  revoked        BOOLEAN NOT NULL DEFAULT FALSE,
  revoked_at     TIMESTAMPTZ,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_used_at   TIMESTAMPTZ,
  user_agent     TEXT,
  ip_address     TEXT
);

CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user ON refresh_tokens (user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON refresh_tokens (token_hash);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON refresh_tokens (expires_at) WHERE NOT revoked;

-- PASSWORD RESET TOKENS
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id        UUID NOT NULL,
  token_hash     TEXT NOT NULL UNIQUE,
  expires_at     TIMESTAMPTZ NOT NULL,
  used_at        TIMESTAMPTZ,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_user ON password_reset_tokens (user_id);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token_hash ON password_reset_tokens (token_hash);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires ON password_reset_tokens (expires_at) WHERE used_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_pending ON password_reset_tokens (user_id, expires_at) WHERE used_at IS NULL;

-- EMAIL VERIFICATION TOKENS
CREATE TABLE IF NOT EXISTS email_verification_tokens (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id        UUID NOT NULL,
  token_hash     TEXT NOT NULL UNIQUE,
  expires_at     TIMESTAMPTZ NOT NULL,
  verified_at    TIMESTAMPTZ,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_user ON email_verification_tokens (user_id);
CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_hash ON email_verification_tokens (token_hash);
CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_pending ON email_verification_tokens (user_id, expires_at) WHERE verified_at IS NULL;

-----------------------------
-- Triggers (updated_at)
-----------------------------
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_set_updated_at') THEN
    CREATE TRIGGER trg_users_set_updated_at
      BEFORE UPDATE ON users
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_orgs_set_updated_at') THEN
    CREATE TRIGGER trg_orgs_set_updated_at
      BEFORE UPDATE ON organizations
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;
END$$;

-----------------------------
-- Views
-----------------------------
CREATE OR REPLACE VIEW v_memberships AS
SELECT
  m.user_id,
  m.org_id,
  m.roles,
  m.member_type,
  m.created_at
FROM memberships m;

CREATE OR REPLACE VIEW v_role_bindings AS
SELECT
  rb.id,
  rb.org_id,
  rb.user_id,
  r.name AS role_name,
  rb.scope,
  rb.scope_id,
  rb.created_at
FROM role_bindings rb
JOIN roles r ON r.id = rb.role_id;

-----------------------------
-- Data seeding is handled by DataInitializer.java
-----------------------------
