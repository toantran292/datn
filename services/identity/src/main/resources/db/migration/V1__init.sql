-- UTS Identity: single migration (schema only; allows SYSTEM scope)
-- Safe to re-run (idempotent). PostgreSQL 13+

-----------------------------
-- Extensions
-----------------------------
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- gen_random_uuid()

-----------------------------
-- Tables
-----------------------------

-- USERS
CREATE TABLE IF NOT EXISTS users (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email          CITEXT NOT NULL UNIQUE,
  password_hash  TEXT   NOT NULL,
  disabled       BOOLEAN NOT NULL DEFAULT FALSE,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ORGANIZATIONS
CREATE TABLE IF NOT EXISTS organizations (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug           CITEXT NOT NULL UNIQUE,
  display_name   TEXT   NOT NULL,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- MEMBERSHIPS (user â†” org; cache roles + member_type)
-- member_type: 'STAFF' | 'PARTNER'
CREATE TABLE IF NOT EXISTS memberships (
  user_id        UUID NOT NULL,
  org_id         UUID NOT NULL,
  roles          TEXT[] NOT NULL DEFAULT '{}',
  member_type    TEXT   NOT NULL DEFAULT 'STAFF',
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, org_id),
  CONSTRAINT memberships_member_type_chk
    CHECK (member_type IN ('STAFF','PARTNER'))
);

-- ROLES (system / custom)
CREATE TABLE IF NOT EXISTS roles (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         CITEXT NOT NULL UNIQUE, -- OWNER, ADMIN, MEMBER, PROJECT_ADMIN, ROOT, SYS_ADMIN, ...
  description  TEXT,
  builtin      BOOLEAN NOT NULL DEFAULT FALSE
);

-- PERMISSIONS (atomic permissions)
CREATE TABLE IF NOT EXISTS permissions (
  id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         CITEXT NOT NULL UNIQUE, -- org.read, user.invite, project.manage, system.manage, ...
  description  TEXT
);

-- ROLE_PERMISSIONS (many-to-many)
CREATE TABLE IF NOT EXISTS role_permissions (
  role_id  INT NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  perm_id  INT NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (role_id, perm_id)
);

-- ROLE_BINDINGS (assign role to user in a scope)
-- scopes: 'SYSTEM' | 'ORG' | 'PROJECT'
CREATE TABLE IF NOT EXISTS role_bindings (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id     UUID,                     -- nullable for SYSTEM scope
  user_id    UUID NOT NULL,            -- logical FK -> users.id
  role_id    INT  NOT NULL REFERENCES roles(id) ON DELETE RESTRICT,
  scope      TEXT NOT NULL DEFAULT 'ORG',
  scope_id   TEXT,                     -- nullable; when PROJECT, store PM.PROJECTS.id
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Ensure scope constraint allows SYSTEM (drop old, add new)
ALTER TABLE role_bindings
  DROP CONSTRAINT IF EXISTS role_bindings_scope_chk;

ALTER TABLE role_bindings
  ADD CONSTRAINT role_bindings_scope_chk
  CHECK (scope IN ('SYSTEM','ORG','PROJECT'));

-- Shape constraint for scope/org_id/scope_id
ALTER TABLE role_bindings
  DROP CONSTRAINT IF EXISTS role_bindings_scope_shape_chk;

ALTER TABLE role_bindings
  ADD CONSTRAINT role_bindings_scope_shape_chk
  CHECK (
    (scope = 'SYSTEM'  AND org_id IS NULL AND scope_id IS NULL) OR
    (scope = 'ORG'     AND org_id IS NOT NULL AND scope_id IS NULL) OR
    (scope = 'PROJECT' AND org_id IS NOT NULL AND scope_id IS NOT NULL)
  );

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_role_bindings_org_user ON role_bindings (org_id, user_id);
CREATE INDEX IF NOT EXISTS idx_role_bindings_scope    ON role_bindings (scope, scope_id);
CREATE INDEX IF NOT EXISTS idx_role_bindings_scope_only ON role_bindings (scope);

-- INVITATIONS (invite to org)
CREATE TABLE IF NOT EXISTS invitations (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id      UUID   NOT NULL,     -- logical FK -> organizations
  email       CITEXT NOT NULL,
  token       TEXT   NOT NULL UNIQUE,
  member_type TEXT   NOT NULL DEFAULT 'STAFF',
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  accepted_at TIMESTAMPTZ,
  CONSTRAINT invitations_member_type_chk
    CHECK (member_type IN ('STAFF','PARTNER'))
);

-- Unique (org_id, email) for open invitations (partial unique index)
CREATE UNIQUE INDEX IF NOT EXISTS ux_invitations_open_unique
  ON invitations (org_id, email)
  WHERE accepted_at IS NULL;

-- AUDIT_LOGS
CREATE TABLE IF NOT EXISTS audit_logs (
  id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  actor_user_id  UUID,              -- logical FK -> users.id
  org_id         UUID,              -- logical FK -> organizations.id
  action         TEXT NOT NULL,     -- e.g. user.invited
  meta           JSONB,             -- extra context
  at             TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_org_time ON audit_logs (org_id, at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor    ON audit_logs (actor_user_id, at DESC);

-- OUTBOX (Transactional Outbox)
CREATE TABLE IF NOT EXISTS outbox (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  topic        TEXT  NOT NULL,     -- identity.user.created, ...
  payload      JSONB NOT NULL,     -- JSONB to store event payload
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  published_at TIMESTAMPTZ
);

-- Efficient polling of unpublished messages
CREATE INDEX IF NOT EXISTS idx_outbox_unpublished
  ON outbox (created_at)
  WHERE published_at IS NULL;

-----------------------------
-- Triggers (updated_at)
-----------------------------
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_set_updated_at') THEN
    CREATE TRIGGER trg_users_set_updated_at
      BEFORE UPDATE ON users
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_orgs_set_updated_at') THEN
    CREATE TRIGGER trg_orgs_set_updated_at
      BEFORE UPDATE ON organizations
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;
END$$;

-----------------------------
-- Views (optional)
-----------------------------
CREATE OR REPLACE VIEW v_memberships AS
SELECT
  m.user_id,
  m.org_id,
  m.roles,
  m.member_type,
  m.created_at
FROM memberships m;

CREATE OR REPLACE VIEW v_role_bindings AS
SELECT
  rb.id,
  rb.org_id,
  rb.user_id,
  r.name AS role_name,
  rb.scope,
  rb.scope_id,
  rb.created_at
FROM role_bindings rb
JOIN roles r ON r.id = rb.role_id;

-----------------------------
-- External identities & user flags
-----------------------------
CREATE TABLE IF NOT EXISTS external_identities (
  provider   TEXT    NOT NULL, -- 'google', ...
  subject    TEXT    NOT NULL, -- sub from id_token
  user_id    UUID    NOT NULL, -- users.id
  email      CITEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (provider, subject)
);

CREATE INDEX IF NOT EXISTS idx_external_by_user ON external_identities(user_id);

ALTER TABLE users
  ADD COLUMN IF NOT EXISTS must_change_password BOOLEAN NOT NULL DEFAULT FALSE;

-----------------------------
-- Data seeding is handled by DataInitializer.java
-- This ensures consistent seeding behavior and better maintainability
-----------------------------
