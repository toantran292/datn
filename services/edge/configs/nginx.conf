worker_processes auto;

env EDGE_HMAC_SECRET;
# env BFF_HMAC_SECRET;

events { worker_connections 4096; }

http {
  # --- shared dict ---
  # Temporarily disabled for development
  # lua_shared_dict authz_cache 100m;
  # lua_shared_dict jwks_cache 10m;

  proxy_headers_hash_max_size 1024;
  proxy_headers_hash_bucket_size 128;

  resolver 127.0.0.11 ipv6=off valid=30s;

  gzip on; gzip_types application/json text/css application/javascript;
  client_max_body_size 25m;

  map $http_upgrade $connection_upgrade { default upgrade; "" close; }

  limit_req_zone $binary_remote_addr zone=api_rl:10m rate=300r/m;

  # small rate-limit (per IP) – tune for prod
  # limit_req_zone $binary_remote_addr zone=api_rl:10m rate=300r/m;

  # --- upstreams ---
  upstream pm_api     { server pm:3000; }
  upstream meet_api   { server meet-api:3000; }
  upstream chat_api         { server chat-api:3000; }
  upstream rag_api          { server rag-api:3000; }
  upstream tenant_bff       { server tenant-bff:3000; }
  # upstream admin_bff        { server admin-bff:3000; }
  upstream identity         { server identity:3000; }
  upstream notification_api { server notification-api:3000; }
  upstream file_storage_api  { server file-storage-api:3000; }

  init_by_lua_block {
    local b64 = ngx.decode_base64

    -- convert base64url → bytes
    local function b64url_to_bytes(s)
      s = s:gsub("-", "+"):gsub("_", "/")
      local pad = #s % 4
      if pad > 0 then s = s .. string.rep("=", 4 - pad) end
      return b64(s)
    end

    -- Convert JWK RSA → PEM using OpenSSL
    jwk_to_pem = function(jwk)
      local x509 = require "resty.openssl.x509"
      local pkey = require "resty.openssl.pkey"

      local n = b64url_to_bytes(jwk.n)
      local e = b64url_to_bytes(jwk.e)

      local key = pkey.new({
        type = "RSA",
        rsa = { n = n, e = e }
      })

      return key:to_PEM("public")
    end
  }

  server {
    listen 80;
    server_name localhost;

    # ---------------- CORS Headers (via Lua) ----------------
    header_filter_by_lua_block {
      ngx.header["Access-Control-Allow-Origin"] = ngx.var.http_origin or "*"
      ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS, PATCH"
      ngx.header["Access-Control-Allow-Headers"] = "Authorization, Content-Type, X-Requested-Org-Id, X-Org-ID, X-Requested-Project-Id, X-Project-ID, X-Request-Id"
      ngx.header["Access-Control-Allow-Credentials"] = "true"
      ngx.header["Access-Control-Max-Age"] = "86400"
    }

    # ---------------- Common AuthZ (Lua) ----------------
    # Edge checks AT (Bearer or cookie uts_at), calls Identity /authz/check,
    # caches result, then sets context + signs HMAC for downstream
    set $uts_authz_ok 0;
    access_by_lua_block {
      if ngx.ctx.uts_check ~= true then
        return
      end

      if ngx.req.get_method() == "OPTIONS" then
        return ngx.exit(204)
      end

      local http        = require "resty.http"
      local cjson       = require "cjson.safe"
      local openssl_hmac = require "resty.openssl.hmac"   -- <= HMAC from OPM

      -- ---- 1) Lấy Access Token ----
      local hdr = ngx.req.get_headers()["Authorization"]
      local at

      if hdr and hdr:match("^Bearer ") then
        at = hdr:gsub("^Bearer%s+", "")
      else
        at = ngx.var.cookie_uts_at
      end

      if not at or at == "" then
        return ngx.exit(401)
      end

      -- ---- 2) Verify token qua Identity ----
      local cli = http.new()
      -- Increase timeout to 5s to reduce intermittent verify failures
      cli:set_timeout(5000)

      -- Call identity /auth/me and capture error details
      local res, err = cli:request_uri("http://identity:3000/auth/me", {
        method = "GET",
        headers = {
          ["Cookie"] = "uts_at=" .. at,
          ["Authorization"] = "Bearer " .. at,
        },
      })

      if not res or res.status ~= 200 then
        ngx.log(ngx.ERR,
          "Identity verify failed: ",
          res and res.status or "no response",
          ", err=", err or "nil"
        )
        return ngx.exit(401)
      end

      local data = cjson.decode(res.body)
      if not data then
        ngx.log(ngx.ERR, "Identity verify invalid JSON")
        return ngx.exit(401)
      end

      local user_id = data.user_id
      local org_id  = data.org_id
      local roles   = data.roles or {}

      if not user_id or not org_id then
        ngx.log(ngx.ERR, "Missing claims after verify")
        return ngx.exit(401)
      end

      -- ---- 3) Forward user → BFF ----
      ngx.req.set_header("X-User-ID", user_id)
      ngx.req.set_header("X-Org-ID", org_id)
      ngx.req.set_header("X-Roles", table.concat(roles, ","))

      local req_id = ngx.req.get_headers()["X-Request-Id"] or ngx.var.request_id
      ngx.req.set_header("X-Request-Id", req_id)

      -- ---- 4) Generate HMAC để BFF verify ----
      local secret = os.getenv("EDGE_HMAC_SECRET")
      if not secret or secret == "" then
        ngx.log(ngx.ERR, "Missing EDGE_HMAC_SECRET")
        return ngx.exit(500)
      end

      local ts = tostring(ngx.time())
      ngx.req.set_header("X-Auth-Timestamp", ts)

      -- raw string giống BFF
      local uid = user_id      -- bạn đã có từ /auth/me
      local org = org_id
      local proj = ngx.req.get_headers()["X-Project-ID"] or ""
      local ts = tostring(ngx.time())

      local raw = string.format("%s|%s|%s|%s", uid, org, proj, ts)

      local h = openssl_hmac.new(secret, "sha256")
      h:update(raw)
      local digest = h:final()
      local sig = "v1 " .. ngx.encode_base64(digest)

      ngx.req.set_header("X-Auth-Signature", sig)

      ngx.ctx.uts_authz_ok = true
    }

    # --------------- /pm ---------------
    location ~* ^/pm(/?|/.*)$ {
      limit_req zone=api_rl burst=80 nodelay;
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;

      # giữ Authorization cho pm-api (tuỳ yêu cầu)
      rewrite ^/pm(/.*)$ $1 break;
      proxy_pass http://pm_api;
    }

    # --------------- /meet ---------------
    # Meeting API already has /meet prefix in its routes, so don't rewrite
    location ~* ^/meet(/?|/.*)$ {
      limit_req zone=api_rl burst=80 nodelay;
      # No auth check - meeting API handles its own auth
      # set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;

      proxy_pass http://meet_api;
    }

    # --------------- /admin/meetings ---------------
    # Admin meeting management endpoints (system admin only)
    location ~* ^/admin/meetings(/?|/.*)$ {
      limit_req zone=api_rl burst=30 nodelay;
      # Admin endpoints - auth handled by meeting API's SystemAdminGuard

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_pass http://meet_api;
    }

    # --------------- /ai (Meeting AI - Translation, etc) ---------------
    location ~* ^/ai(/?|/.*)$ {
      limit_req zone=api_rl burst=60 nodelay;
      # No auth required for AI endpoints (translation is public)

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_pass http://meet_api;
    }

    # --------------- /transcripts ---------------
    # Transcript management for meeting captions
    location ~* ^/transcripts(/?|/.*)$ {
      limit_req zone=api_rl burst=30 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_pass http://meet_api;
    }

    # --------------- /chat ---------------
    # Socket.IO with namespace requires keeping the /chat prefix
    location ~* ^/chat(/?|/.*)$ {
      limit_req zone=api_rl burst=120 nodelay;  # chat thường nhiều request hơn
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header Content-Type $content_type;
      proxy_set_header Content-Length $content_length;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;

      # Buffer settings to handle request body
      proxy_buffering off;
      proxy_request_buffering off;
      client_max_body_size 10M;

      # Don't rewrite - keep /chat prefix for Socket.IO namespace
      rewrite ^/chat(/.*)$ $1 break;
      proxy_pass http://chat_api;
    }

    # --------------- /notifications ---------------
    # REST API and WebSocket for notifications
    location ~* ^/notifications(/?|/.*)$ {
      limit_req zone=api_rl burst=200 nodelay;

      # Enable auth check to get X-User-ID header
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Real-IP $remote_addr;

      # WebSocket upgrade headers
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;

      # Timeouts for long-lived WebSocket connections
      proxy_read_timeout 3600s;
      proxy_send_timeout 3600s;

      # Disable buffering for real-time communication
      proxy_buffering off;

      # DO NOT rewrite - keep /notifications prefix for Socket.IO path matching
      proxy_pass http://notification_api;
    }

    # --------------- Handle CORS Preflight (OPTIONS) ---------------
    location / {
      if ($request_method = 'OPTIONS') {
        return 204;
      }
      return 404;
    }

    # --------------- /auth (Identity Service - No AuthZ Check) ---------------
    location ~* ^/auth(/?|/.*)$ {
      # Handle CORS preflight (headers set by header_filter_by_lua_block)
      if ($request_method = 'OPTIONS') {
        return 204;
      }

      limit_req zone=api_rl burst=120 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Forwarded-Port 8080;
      proxy_http_version 1.1;

      # Pass through without rewriting path
      proxy_pass http://identity;
    }

    # --------------- /me (Identity Service - No AuthZ, already authenticated by cookie) ---------------
    location ~* ^/me(/?|/.*)$ {
      # Handle CORS preflight (headers set by header_filter_by_lua_block)
      if ($request_method = 'OPTIONS') {
        return 204;
      }

      limit_req zone=api_rl burst=60 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_http_version 1.1;

      # Pass through without rewriting path
      proxy_pass http://identity;
    }

    location ~* ^/orgs(/?|/.*)$ {
      # Handle CORS preflight (headers set by header_filter_by_lua_block)
      if ($request_method = 'OPTIONS') {
        return 204;
      }

      limit_req zone=api_rl burst=60 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_http_version 1.1;

      # Pass through without rewriting path
      proxy_pass http://identity;
    }


    # --------------- /oauth2 (Identity Service - OAuth flows) ---------------
    location ~* ^/oauth2(/?|/.*)$ {
      # Handle CORS preflight (headers set by header_filter_by_lua_block)
      if ($request_method = 'OPTIONS') {
        return 204;
      }

      limit_req zone=api_rl burst=80 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Forwarded-Port 8080;
      proxy_http_version 1.1;

      # Pass through without rewriting path
      proxy_pass http://identity;
    }

    location ~* ^/login/oauth2/code/google(/?|/.*)$ {
      # Handle CORS preflight (headers set by header_filter_by_lua_block)
      if ($request_method = 'OPTIONS') {
        return 204;
      }

      limit_req zone=api_rl burst=80 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Forwarded-Port 8080;
      proxy_http_version 1.1;

      # Pass through without rewriting path
      proxy_pass http://identity;
    }

    # --------------- /admin-api (Admin BFF) ---------------
    # Temporarily disabled - admin-bff has build issues
    # location = /admin-api/healthz {
    #   proxy_set_header Host $host;
    #   proxy_pass http://admin_bff/health;
    #   break;
    # }

    # location ~* ^/admin-api(/?|/.*)$ {
    #   limit_req zone=api_rl burst=30 nodelay;
    #   set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

    #   proxy_set_header Host $host;
    #   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #   proxy_set_header X-Forwarded-Proto $scheme;

    #   proxy_set_header Authorization "";

    #   rewrite ^/admin-api(/.*)$ $1 break;
    #   proxy_pass http://admin_bff;
    # }

    # --------------- /tenant (BFF) ---------------
    location = /tenant/healthz {
      proxy_set_header Host $host;
      proxy_pass http://tenant_bff/health;
      break;
    }

    # Public endpoints - no auth required
    location ~* ^/tenant/public(/?|/.*)$ {
      # Handle CORS preflight
      if ($request_method = 'OPTIONS') {
        return 204;
      }

      limit_req zone=api_rl burst=60 nodelay;

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      rewrite ^/tenant(/.*)$ $1 break;
      proxy_pass http://tenant_bff;
    }

    # SSE streaming endpoint for agent chat
    location ~* ^/tenant/agent/chat/stream$ {
      limit_req zone=api_rl burst=60 nodelay;
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header Authorization "";

      # SSE specific settings
      proxy_http_version 1.1;
      proxy_set_header Connection "";
      proxy_buffering off;
      proxy_cache off;
      proxy_read_timeout 120s;

      # Disable gzip for SSE
      gzip off;

      rewrite ^/tenant(/.*)$ $1 break;
      proxy_pass http://tenant_bff;
    }

    location ~* ^/tenant(/?|/.*)$ {
      limit_req zone=api_rl burst=60 nodelay;
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_set_header Authorization "";

      rewrite ^/tenant(/.*)$ $1 break;
      proxy_pass http://tenant_bff;
    }

    # --------------- /files (File Storage Service) ---------------
    location ~* ^/files(/?|/.*)$ {
      limit_req zone=api_rl burst=120 nodelay;
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_http_version 1.1;

      # Buffer settings for file uploads
      proxy_buffering off;
      proxy_request_buffering off;
      client_max_body_size 25M;

      # Pass through without rewriting path
      proxy_pass http://file_storage_api;
    }

    # --------------- /rag (RAG Service - Embeddings, Search, Ask) ---------------
    location = /rag/healthz {
      proxy_set_header Host $host;
      proxy_pass http://rag_api/health;
      break;
    }

    location ~* ^/rag(/?|/.*)$ {
      limit_req zone=api_rl burst=60 nodelay;
      set_by_lua_block $dummy { ngx.ctx.uts_check = true return "" }

      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_http_version 1.1;

      # Longer timeouts for LLM operations
      proxy_read_timeout 120s;
      proxy_send_timeout 120s;

      # Buffer settings for streaming responses
      proxy_buffering off;

      rewrite ^/rag(/.*)$ $1 break;
      proxy_pass http://rag_api;
    }

    location = /healthz { return 200; }
  }
}