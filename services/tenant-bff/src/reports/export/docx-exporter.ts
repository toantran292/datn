import { Report } from '../entities/report.entity';
import { ExportResult } from './export.types';

/**
 * DOCX Exporter using docx library.
 * Generates professional Word documents with proper formatting.
 */
export class DocxExporter {
  async export(report: Report, includeMetadata: boolean = true): Promise<ExportResult> {
    // Note: In production, use the 'docx' npm package for proper DOCX generation
    // npm install docx
    // For now, generate a simple XML-based DOCX structure

    const content = this.generateDocxContent(report, includeMetadata);
    const buffer = Buffer.from(content, 'utf-8');
    const filename = this.sanitizeFilename(report.name) + '.docx';

    return {
      buffer,
      filename,
      mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    };
  }

  private generateDocxContent(report: Report, includeMetadata: boolean): string {
    // Generate Office Open XML format
    // This is a simplified version - in production use the docx library

    const contentXml = this.markdownToDocxXml(report.content || '');

    const metadataSection = includeMetadata ? `
      <w:p>
        <w:pPr><w:pStyle w:val="Heading2"/></w:pPr>
        <w:r><w:t>Report Information</w:t></w:r>
      </w:p>
      <w:tbl>
        <w:tblPr>
          <w:tblW w:w="5000" w:type="pct"/>
          <w:tblBorders>
            <w:top w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:left w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:bottom w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:right w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:insideH w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:insideV w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          </w:tblBorders>
        </w:tblPr>
        ${this.generateTableRow('Report Type', report.type)}
        ${this.generateTableRow('Status', report.status)}
        ${this.generateTableRow('Created', new Date(report.createdAt).toLocaleString())}
        ${report.completedAt ? this.generateTableRow('Completed', new Date(report.completedAt).toLocaleString()) : ''}
        ${report.llmProvider ? this.generateTableRow('AI Provider', report.llmProvider) : ''}
        ${report.llmModel ? this.generateTableRow('Model', report.llmModel) : ''}
      </w:tbl>
    ` : '';

    const descriptionSection = report.description ? `
      <w:p>
        <w:pPr><w:pStyle w:val="Heading2"/></w:pPr>
        <w:r><w:t>Description</w:t></w:r>
      </w:p>
      <w:p>
        <w:r><w:t>${this.escapeXml(report.description)}</w:t></w:r>
      </w:p>
    ` : '';

    const tokenUsageSection = includeMetadata && report.tokenUsage ? `
      <w:p>
        <w:pPr><w:pStyle w:val="Heading2"/></w:pPr>
        <w:r><w:t>Token Usage Statistics</w:t></w:r>
      </w:p>
      <w:tbl>
        <w:tblPr>
          <w:tblW w:w="5000" w:type="pct"/>
          <w:tblBorders>
            <w:top w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:left w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:bottom w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:right w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:insideH w:val="single" w:sz="4" w:space="0" w:color="auto"/>
            <w:insideV w:val="single" w:sz="4" w:space="0" w:color="auto"/>
          </w:tblBorders>
        </w:tblPr>
        ${Object.entries(report.tokenUsage).map(([key, value]) =>
          this.generateTableRow(this.formatKey(key), String(value))
        ).join('')}
      </w:tbl>
    ` : '';

    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<?mso-application progid="Word.Document"?>
<w:wordDocument xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml">
  <w:body>
    <w:p>
      <w:pPr><w:pStyle w:val="Title"/></w:pPr>
      <w:r><w:t>${this.escapeXml(report.name)}</w:t></w:r>
    </w:p>

    ${metadataSection}
    ${descriptionSection}

    <w:p>
      <w:pPr><w:pStyle w:val="Heading2"/></w:pPr>
      <w:r><w:t>Report Content</w:t></w:r>
    </w:p>
    ${contentXml}

    ${tokenUsageSection}

    <w:p>
      <w:pPr>
        <w:pBdr>
          <w:top w:val="single" w:sz="4" w:space="1" w:color="CCCCCC"/>
        </w:pBdr>
        <w:jc w:val="center"/>
      </w:pPr>
      <w:r>
        <w:rPr><w:color w:val="888888"/><w:sz w:val="20"/></w:rPr>
        <w:t>Generated by AI Report System | ${new Date().toLocaleDateString()}</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:wordDocument>`;
  }

  private generateTableRow(label: string, value: string): string {
    return `
      <w:tr>
        <w:tc>
          <w:tcPr><w:tcW w:w="2500" w:type="pct"/></w:tcPr>
          <w:p><w:r><w:rPr><w:b/></w:rPr><w:t>${this.escapeXml(label)}</w:t></w:r></w:p>
        </w:tc>
        <w:tc>
          <w:tcPr><w:tcW w:w="2500" w:type="pct"/></w:tcPr>
          <w:p><w:r><w:t>${this.escapeXml(value)}</w:t></w:r></w:p>
        </w:tc>
      </w:tr>`;
  }

  private markdownToDocxXml(markdown: string): string {
    if (!markdown) {
      return '<w:p><w:r><w:rPr><w:i/></w:rPr><w:t>No content generated</w:t></w:r></w:p>';
    }

    const lines = markdown.split('\n');
    const paragraphs: string[] = [];

    for (const line of lines) {
      if (!line.trim()) {
        continue;
      }

      // Headers
      if (line.startsWith('### ')) {
        paragraphs.push(`
          <w:p>
            <w:pPr><w:pStyle w:val="Heading3"/></w:pPr>
            <w:r><w:t>${this.escapeXml(line.slice(4))}</w:t></w:r>
          </w:p>`);
      } else if (line.startsWith('## ')) {
        paragraphs.push(`
          <w:p>
            <w:pPr><w:pStyle w:val="Heading2"/></w:pPr>
            <w:r><w:t>${this.escapeXml(line.slice(3))}</w:t></w:r>
          </w:p>`);
      } else if (line.startsWith('# ')) {
        paragraphs.push(`
          <w:p>
            <w:pPr><w:pStyle w:val="Heading1"/></w:pPr>
            <w:r><w:t>${this.escapeXml(line.slice(2))}</w:t></w:r>
          </w:p>`);
      }
      // List items
      else if (line.startsWith('- ') || line.match(/^\d+\. /)) {
        const content = line.startsWith('- ') ? line.slice(2) : line.replace(/^\d+\. /, '');
        paragraphs.push(`
          <w:p>
            <w:pPr>
              <w:numPr><w:ilvl w:val="0"/><w:numId w:val="1"/></w:numPr>
            </w:pPr>
            <w:r><w:t>${this.escapeXml(this.processInlineFormatting(content))}</w:t></w:r>
          </w:p>`);
      }
      // Blockquote
      else if (line.startsWith('> ')) {
        paragraphs.push(`
          <w:p>
            <w:pPr>
              <w:pBdr><w:left w:val="single" w:sz="18" w:space="4" w:color="CCCCCC"/></w:pBdr>
              <w:ind w:left="720"/>
            </w:pPr>
            <w:r>
              <w:rPr><w:color w:val="666666"/></w:rPr>
              <w:t>${this.escapeXml(line.slice(2))}</w:t>
            </w:r>
          </w:p>`);
      }
      // Horizontal rule
      else if (line.trim() === '---') {
        paragraphs.push(`
          <w:p>
            <w:pPr>
              <w:pBdr><w:bottom w:val="single" w:sz="6" w:space="1" w:color="auto"/></w:pBdr>
            </w:pPr>
          </w:p>`);
      }
      // Code block
      else if (line.startsWith('```')) {
        // Skip code fence markers
        continue;
      }
      // Regular paragraph
      else {
        const processed = this.processInlineFormatting(line);
        paragraphs.push(`
          <w:p>
            <w:r><w:t>${this.escapeXml(processed)}</w:t></w:r>
          </w:p>`);
      }
    }

    return paragraphs.join('\n');
  }

  private processInlineFormatting(text: string): string {
    // Remove markdown inline formatting for plain text
    // In production with docx library, we would apply actual formatting
    return text
      .replace(/\*\*\*(.*?)\*\*\*/g, '$1')
      .replace(/\*\*(.*?)\*\*/g, '$1')
      .replace(/\*(.*?)\*/g, '$1')
      .replace(/`([^`]+)`/g, '$1');
  }

  private formatKey(key: string): string {
    return key
      .replace(/_/g, ' ')
      .replace(/\b\w/g, (c) => c.toUpperCase());
  }

  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  private sanitizeFilename(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 50);
  }
}
